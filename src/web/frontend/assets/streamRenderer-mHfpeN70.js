(function(){"use strict";function d(t,e,r,a){const o=Math.max(r/t,a/e),l=t*o,c=e*o,n=(r-l)/2,s=(a-c)/2;return{drawW:l,drawH:c,offsetX:n,offsetY:s}}function h(t,e,r){let a=e,o=r,l=-1,c=-1;for(let n=0;n<r;n++)for(let s=0;s<e;s++)if(t[(n*e+s)*4+3]<255){o=n,n=r;break}for(let n=r-1;n>=0;n--)for(let s=0;s<e;s++)if(t[(n*e+s)*4+3]<255){c=n,n=-1;break}for(let n=0;n<e;n++)for(let s=o;s<=c;s++)if(t[(s*e+n)*4+3]<255){a=n,n=e;break}for(let n=e-1;n>=0;n--)for(let s=o;s<=c;s++)if(t[(s*e+n)*4+3]<255){l=n,n=-1;break}return{minX:a,minY:o,maxX:l,maxY:c}}async function m(t,e=8){const r=Math.ceil(t.width/e),a=Math.ceil(t.height/e),l=new OffscreenCanvas(r,a).getContext("2d",{willReadFrequently:!0,alpha:!0});l.drawImage(t,0,0,r,a);const c=l.getImageData(0,0,r,a),{minX:n,minY:s,maxX:i,maxY:g}=h(c.data,r,a);return{x:n*e,y:s*e,width:(i-n+1)*e,height:(g-s+1)*e}}async function p(t){const e=performance.now(),a=await(await fetch(t)).blob(),o=await createImageBitmap(a),l=await m(o),c=performance.now();return console.log("load overlay+calc transparency bbox took ",(c-e).toFixed(1),"ms, bbox is ",l),{bitmap:o,transparentBBox:l}}function u(t,e,r,a){const o=r&&r.bitmap?r.bitmap.width:e.width,l=r&&r.bitmap?r.bitmap.height:e.height;if((t.canvas.width!==o||t.canvas.height!==l)&&(t.canvas.width=o,t.canvas.height=l,console.log(`set stream canvas size to ${o}x${l}`)),r&&r.bitmap&&r.transparentBBox){const{drawW:c,drawH:n,offsetX:s,offsetY:i}=d(e.width,e.height,r.transparentBBox.width,r.transparentBBox.height);a.enableMirrorEffectStream?t.ctx.setTransform(-1,0,0,1,t.canvas.width,0):t.ctx.resetTransform(),t.ctx.drawImage(e,r.transparentBBox.x+s,r.transparentBBox.y+i,c,n),a.enableMirrorEffectFrame?t.ctx.setTransform(-1,0,0,1,t.canvas.width,0):t.ctx.resetTransform(),t.ctx.drawImage(r.bitmap,0,0),a.debugRectangleBbox&&(t.ctx.strokeStyle="red",t.ctx.lineWidth=2,t.ctx.strokeRect(r.transparentBBox.x,r.transparentBBox.y,r.transparentBBox.width,r.transparentBBox.height))}else a.enableMirrorEffectStream?t.ctx.setTransform(-1,0,0,1,t.canvas.width,0):t.ctx.resetTransform(),t.ctx.drawImage(e,0,0)}function w(t,e,r){const a=Math.ceil(e.width/16),o=Math.ceil(e.height/16);(t.canvas.width!==a||t.canvas.height!==o)&&(t.canvas.width=a,t.canvas.height=o,console.log(`set blur canvas size to ${a}x${o}`)),r.enableMirrorEffectStream?t.ctx.setTransform(-1,0,0,1,t.canvas.width,0):t.ctx.resetTransform(),t.ctx.drawImage(e,0,0,a,o)}class b{stream=null;blurred=null;currentOverlay=null;config={enableBlurredBackgroundStream:!1,enableMirrorEffectStream:!1,enableMirrorEffectFrame:!1,blurInterval:300,debugRectangleBbox:!1};draw={isDrawing:!1,droppedFrameCount:0,lastLog:performance.now(),lastBlurUpdate:0};init(e,r){this.stream={canvas:e.stream,ctx:e.stream.getContext("2d",{alpha:!1})},this.blurred={canvas:e.blurred,ctx:e.blurred.getContext("2d",{alpha:!1})},Object.assign(this.config,r),this.draw.lastLog=performance.now(),this.draw.lastBlurUpdate=0,this.draw.droppedFrameCount=0,console.log("StreamRenderer initialized with config",this.config)}async updateOverlay(e){let r=null;try{e&&(r=await p(e))}catch(a){console.error("updateOverlay error",a)}finally{const a=this.currentOverlay;if(this.currentOverlay=r,a?.bitmap)try{a.bitmap.close()}catch{}}}async drawFrame(e){if(!this.stream){console.warn("drawFrame called before init");return}if(this.draw.isDrawing){this.draw.droppedFrameCount++;return}this.draw.isDrawing=!0;const r=performance.now();let a=null;try{const o=new Blob([e],{type:"image/jpeg"});if(a=await createImageBitmap(o),u(this.stream,a,this.currentOverlay,this.config),this.config.enableBlurredBackgroundStream&&this.blurred){const l=performance.now();l-this.draw.lastBlurUpdate>=this.config.blurInterval&&(w(this.blurred,a,this.config),this.draw.lastBlurUpdate=l)}}catch(o){console.error("drawFrame error",o)}finally{if(a)try{a.close()}catch{}this.draw.isDrawing=!1;const o=performance.now(),l=o-r;o-this.draw.lastLog>=2e3&&(console.log("drawFrame took",l.toFixed(1),"ms, droppedFrameCount is",this.draw.droppedFrameCount),this.draw.lastLog=o,this.draw.droppedFrameCount=0)}}}const f=new b;self.onmessage=async t=>{const e=t.data;try{if(e.type==="init"){const r=e.canvases,a={enableMirrorEffectStream:!!e.enableMirrorEffectStream,enableMirrorEffectFrame:!!e.enableMirrorEffectFrame,enableBlurredBackgroundStream:!!e.enableBlurredBackgroundStream,blurInterval:e.blurredbackgroundHighFramerate?50:300};f.init(r,a)}else e.type==="frame"?f.drawFrame(e.payload):e.type==="overlay"?(await f.updateOverlay(e.url??null),console.log(`overlay updated to ${e.url}`)):console.warn("unknown message type",e.type)}catch(r){console.error("onmessage handler error",r)}}})();
