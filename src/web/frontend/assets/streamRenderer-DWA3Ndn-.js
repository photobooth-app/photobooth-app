(function(){"use strict";function m(t,e,r,a){const n=Math.max(r/t,a/e),s=t*n,c=e*n,o=(r-s)/2,i=(a-c)/2;return{drawW:s,drawH:c,offsetX:o,offsetY:i}}function p(t,e,r){let a=e,n=r,s=-1,c=-1;for(let o=0;o<r;o++)for(let i=0;i<e;i++)if(t[(o*e+i)*4+3]<255){n=o,o=r;break}for(let o=r-1;o>=0;o--)for(let i=0;i<e;i++)if(t[(o*e+i)*4+3]<255){c=o,o=-1;break}for(let o=0;o<e;o++)for(let i=n;i<=c;i++)if(t[(i*e+o)*4+3]<255){a=o,o=e;break}for(let o=e-1;o>=0;o--)for(let i=n;i<=c;i++)if(t[(i*e+o)*4+3]<255){s=o,o=-1;break}return{minX:a,minY:n,maxX:s,maxY:c}}async function u(t,e=8){const r=Math.ceil(t.width/e),a=Math.ceil(t.height/e),s=new OffscreenCanvas(r,a).getContext("2d",{willReadFrequently:!0,alpha:!0});s.drawImage(t,0,0,r,a);const c=s.getImageData(0,0,r,a),{minX:o,minY:i,maxX:l,maxY:f}=p(c.data,r,a);return{x:o*e,y:i*e,width:(l-o+1)*e,height:(f-i+1)*e}}async function w(t){const e=performance.now(),a=await(await fetch(t)).blob(),n=await createImageBitmap(a),s=await u(n),c=performance.now();return console.log("load overlay+calc transparency bbox took ",(c-e).toFixed(1),"ms, bbox is ",s),{bitmap:n,transparentBBox:s}}function h(t){return"codedWidth"in t?{width:t.displayWidth??t.codedWidth,height:t.displayHeight??t.codedHeight}:{width:t.width,height:t.height}}function g(t,e,r,a){const n=h(e),s=r&&r.bitmap?r.bitmap.width:n.width,c=r&&r.bitmap?r.bitmap.height:n.height;if((t.canvas.width!==s||t.canvas.height!==c)&&(t.canvas.width=s,t.canvas.height=c,console.log(`set stream canvas size to ${s}x${c}`)),r&&r.bitmap&&r.transparentBBox){const{drawW:o,drawH:i,offsetX:l,offsetY:f}=m(n.width,n.height,r.transparentBBox.width,r.transparentBBox.height);a.enableMirrorEffectStream?t.ctx.setTransform(-1,0,0,1,t.canvas.width,0):t.ctx.resetTransform(),t.ctx.drawImage(e,r.transparentBBox.x+l,r.transparentBBox.y+f,o,i),a.enableMirrorEffectFrame?t.ctx.setTransform(-1,0,0,1,t.canvas.width,0):t.ctx.resetTransform(),t.ctx.drawImage(r.bitmap,0,0),a.debugRectangleBbox&&(t.ctx.strokeStyle="red",t.ctx.lineWidth=2,t.ctx.strokeRect(r.transparentBBox.x,r.transparentBBox.y,r.transparentBBox.width,r.transparentBBox.height))}else a.enableMirrorEffectStream?t.ctx.setTransform(-1,0,0,1,t.canvas.width,0):t.ctx.resetTransform(),t.ctx.drawImage(e,0,0)}function x(t,e,r){const a=h(e),n=Math.ceil(a.width/16),s=Math.ceil(a.height/16);(t.canvas.width!==n||t.canvas.height!==s)&&(t.canvas.width=n,t.canvas.height=s,console.log(`set blur canvas size to ${n}x${s}`)),r.enableMirrorEffectStream?t.ctx.setTransform(-1,0,0,1,t.canvas.width,0):t.ctx.resetTransform(),t.ctx.drawImage(e,0,0,n,s)}class b{stream=null;blurred=null;currentOverlay=null;streamRendererImageDecoderMode=!1;config={enableBlurredBackgroundStream:!1,enableMirrorEffectStream:!1,enableMirrorEffectFrame:!1,blurInterval:300,debugRectangleBbox:!1};draw={isDrawing:!1,droppedFrameCount:0,lastLog:performance.now(),lastBlurUpdate:0};init(e,r,a){this.stream={canvas:e.stream,ctx:e.stream.getContext("2d",{alpha:!1})},this.blurred={canvas:e.blurred,ctx:e.blurred.getContext("2d",{alpha:!1})},this.streamRendererImageDecoderMode=r,Object.assign(this.config,a),this.draw.lastLog=performance.now(),this.draw.lastBlurUpdate=0,this.draw.droppedFrameCount=0,console.log("StreamRenderer initialized with config",this.config)}async updateOverlay(e){let r=null;try{e&&(r=await w(e))}catch(a){console.error("updateOverlay error",a)}finally{const a=this.currentOverlay;if(this.currentOverlay=r,a?.bitmap)try{a.bitmap.close()}catch{}}}async drawFrame(e){if(!this.stream){console.warn("drawFrame called before init");return}if(this.draw.isDrawing){this.draw.droppedFrameCount++;return}this.draw.isDrawing=!0;const r=performance.now();let a=null;try{if(this.streamRendererImageDecoderMode?a=(await new ImageDecoder({data:e,type:"image/jpeg"}).decode()).image:a=await createImageBitmap(e),g(this.stream,a,this.currentOverlay,this.config),this.config.enableBlurredBackgroundStream&&this.blurred){const n=performance.now();(n-this.draw.lastBlurUpdate>=this.config.blurInterval||this.draw.lastBlurUpdate==0)&&(x(this.blurred,a,this.config),this.draw.lastBlurUpdate=n)}}catch(n){console.error("drawFrame error",n)}finally{if(a)try{a.close()}catch{}this.draw.isDrawing=!1;const n=performance.now(),s=n-r;n-this.draw.lastLog>=2e3&&this.draw.droppedFrameCount>0&&(console.log("drawFrame took",s.toFixed(1),"ms, droppedFrameCount is",this.draw.droppedFrameCount),this.draw.lastLog=n,this.draw.droppedFrameCount=0)}}}const d=new b;self.onmessage=async t=>{const e=t.data;try{if(e.type==="init"){const r=e.canvases,a={enableMirrorEffectStream:!!e.enableMirrorEffectStream,enableMirrorEffectFrame:!!e.enableMirrorEffectFrame,enableBlurredBackgroundStream:!!e.enableBlurredBackgroundStream,blurInterval:e.blurredbackgroundHighFramerate?50:300};d.init(r,e.streamRendererImageDecoderMode,a)}else e.type==="frame"?d.drawFrame(e.payload):e.type==="overlay"?(await d.updateOverlay(e.url??null),console.log(`overlay updated to ${e.url}`)):console.warn("unknown message type",e.type)}catch(r){console.error("onmessage handler error",r)}}})();
