(function(){"use strict";function m(e,t,r,a){const n=Math.max(r/e,a/t),s=e*n,c=t*n,o=(r-s)/2,i=(a-c)/2;return{drawW:s,drawH:c,offsetX:o,offsetY:i}}function p(e,t,r){let a=t,n=r,s=-1,c=-1;for(let o=0;o<r;o++)for(let i=0;i<t;i++)if(e[(o*t+i)*4+3]<255){n=o,o=r;break}for(let o=r-1;o>=0;o--)for(let i=0;i<t;i++)if(e[(o*t+i)*4+3]<255){c=o,o=-1;break}for(let o=0;o<t;o++)for(let i=n;i<=c;i++)if(e[(i*t+o)*4+3]<255){a=o,o=t;break}for(let o=t-1;o>=0;o--)for(let i=n;i<=c;i++)if(e[(i*t+o)*4+3]<255){s=o,o=-1;break}return{minX:a,minY:n,maxX:s,maxY:c}}async function u(e,t=8){const r=Math.ceil(e.width/t),a=Math.ceil(e.height/t),s=new OffscreenCanvas(r,a).getContext("2d",{willReadFrequently:!0,alpha:!0});s.drawImage(e,0,0,r,a);const c=s.getImageData(0,0,r,a),{minX:o,minY:i,maxX:l,maxY:f}=p(c.data,r,a);return{x:o*t,y:i*t,width:(l-o+1)*t,height:(f-i+1)*t}}async function w(e){const t=performance.now(),a=await(await fetch(e)).blob(),n=await createImageBitmap(a),s=await u(n),c=performance.now();return console.log("load overlay+calc transparency bbox took ",(c-t).toFixed(1),"ms, bbox is ",s),{bitmap:n,transparentBBox:s}}function h(e){return"codedWidth"in e?{width:e.displayWidth??e.codedWidth,height:e.displayHeight??e.codedHeight}:{width:e.width,height:e.height}}function g(e,t,r,a){const n=h(t),s=r&&r.bitmap?r.bitmap.width:n.width,c=r&&r.bitmap?r.bitmap.height:n.height;if((e.canvas.width!==s||e.canvas.height!==c)&&(e.canvas.width=s,e.canvas.height=c,console.log(`set stream canvas size to ${s}x${c}`)),r&&r.bitmap&&r.transparentBBox){const{drawW:o,drawH:i,offsetX:l,offsetY:f}=m(n.width,n.height,r.transparentBBox.width,r.transparentBBox.height);a.enableMirrorEffectStream?e.ctx.setTransform(-1,0,0,1,e.canvas.width,0):e.ctx.resetTransform(),e.ctx.drawImage(t,r.transparentBBox.x+l,r.transparentBBox.y+f,o,i),a.enableMirrorEffectFrame?e.ctx.setTransform(-1,0,0,1,e.canvas.width,0):e.ctx.resetTransform(),e.ctx.drawImage(r.bitmap,0,0),a.debugRectangleBbox&&(e.ctx.strokeStyle="red",e.ctx.lineWidth=2,e.ctx.strokeRect(r.transparentBBox.x,r.transparentBBox.y,r.transparentBBox.width,r.transparentBBox.height))}else a.enableMirrorEffectStream?e.ctx.setTransform(-1,0,0,1,e.canvas.width,0):e.ctx.resetTransform(),e.ctx.drawImage(t,0,0)}function x(e,t,r){const a=h(t),n=Math.ceil(a.width/16),s=Math.ceil(a.height/16);(e.canvas.width!==n||e.canvas.height!==s)&&(e.canvas.width=n,e.canvas.height=s,console.log(`set blur canvas size to ${n}x${s}`)),r.enableMirrorEffectStream?e.ctx.setTransform(-1,0,0,1,e.canvas.width,0):e.ctx.resetTransform(),e.ctx.drawImage(t,0,0,n,s)}class b{stream=null;blurred=null;currentOverlay=null;config={enableBlurredBackgroundStream:!1,enableMirrorEffectStream:!1,enableMirrorEffectFrame:!1,blurInterval:300,debugRectangleBbox:!1};draw={isDrawing:!1,droppedFrameCount:0,lastLog:performance.now(),lastBlurUpdate:0};init(t,r){this.stream={canvas:t.stream,ctx:t.stream.getContext("2d",{alpha:!1})},this.blurred={canvas:t.blurred,ctx:t.blurred.getContext("2d",{alpha:!1})},Object.assign(this.config,r),this.draw.lastLog=performance.now(),this.draw.lastBlurUpdate=0,this.draw.droppedFrameCount=0,console.log("StreamRenderer initialized with config",this.config)}async updateOverlay(t){let r=null;try{t&&(r=await w(t))}catch(a){console.error("updateOverlay error",a)}finally{const a=this.currentOverlay;if(this.currentOverlay=r,a?.bitmap)try{a.bitmap.close()}catch{}}}async drawFrame(t){if(!this.stream){console.warn("drawFrame called before init");return}if(this.draw.isDrawing){this.draw.droppedFrameCount++;return}this.draw.isDrawing=!0;const r=performance.now();let a=null;try{if(typeof ImageDecoder<"u"?a=(await new ImageDecoder({data:t,type:"image/jpeg"}).decode()).image:a=await createImageBitmap(t),g(this.stream,a,this.currentOverlay,this.config),this.config.enableBlurredBackgroundStream&&this.blurred){const n=performance.now();n-this.draw.lastBlurUpdate>=this.config.blurInterval&&(x(this.blurred,a,this.config),this.draw.lastBlurUpdate=n)}}catch(n){console.error("drawFrame error",n)}finally{if(a)try{a.close()}catch{}this.draw.isDrawing=!1;const n=performance.now(),s=n-r;n-this.draw.lastLog>=2e3&&(console.log("drawFrame took",s.toFixed(1),"ms, droppedFrameCount is",this.draw.droppedFrameCount),this.draw.lastLog=n,this.draw.droppedFrameCount=0)}}}const d=new b;self.onmessage=async e=>{const t=e.data;try{if(t.type==="init"){const r=t.canvases,a={enableMirrorEffectStream:!!t.enableMirrorEffectStream,enableMirrorEffectFrame:!!t.enableMirrorEffectFrame,enableBlurredBackgroundStream:!!t.enableBlurredBackgroundStream,blurInterval:t.blurredbackgroundHighFramerate?50:300};d.init(r,a)}else t.type==="frame"?d.drawFrame(t.payload):t.type==="overlay"?(await d.updateOverlay(t.url??null),console.log(`overlay updated to ${t.url}`)):console.warn("unknown message type",t.type)}catch(r){console.error("onmessage handler error",r)}}})();
